{
  "courseId": "DSA101",
  "lessons": [
    {
      "lesson_no": 1,
      "title": "Introduction to DSA",
      "time": "30 minutes",
      "description": "Start your journey by understanding what Data Structures and Algorithms (DSA) are, why they're important, and how they're used in computer science.",
      "pages": [
        {
          "page_no": 1,
          "heading": "What Are Data Structures and Algorithms?",
          "content": [
            "DSA stands for Data Structures and Algorithms.",
            "A data structure organizes data for efficient access and modification. An algorithm is a step-by-step solution to a problem.",
            "https://i.pinimg.com/1200x/a5/26/88/a5268894a1dff384c83fe89c43bf2a10.jpg",
            "Understanding DSA is foundational for every programmer and helps in designing efficient solutions."
          ]
        },
        {
          "page_no": 2,
          "heading": "Why Learn DSA?",
          "content": [
            "DSA knowledge enables you to write efficient code.",
            "Coding interviews focus heavily on DSA concepts.",
            "Improves ability to debug, optimize, and scale code in real-life projects.",
            "Here are the lessons that we will learn in this course: Arrays, Stacks & Queues, LinkLists, Trees and Binary Trees, Binary Search Trees & Balanced Trees, Hash Tables and Sets, Sorting & Searching Algorithms and many more."
          ]
        },
        {
          "page_no": 3,
          "heading": "Arrays",
          "content": [
            "An array is a collection of items stored at contiguous memory locations. It is used to store multiple items of the same type together, but in python we have lists. Lists are dynamic arrays that can grow and shrink in size and they are hetrogeneous. That means they can store different types of data.",
            "Here is an example of an List in Python:",
            "```\narr = [1, 2, 3, 4, 5]\nprint(arr)\n```",
            "Lists are versatile and can be used for various applications, such as storing collections of items, implementing stacks and queues, and more.",
            "https://i.pinimg.com/736x/7c/2a/d7/7c2ad7134e6b67cb4ed4dca337582d32.jpg"
          ]
        },
        {
          "page_no": 4,
          "heading": "Indexing in Arrays",
          "content": [
            "In Python, lists are zero-indexed, meaning the first element is at index 0.",
            "You can access elements using their index, like `arr[0]` for the first element.",
            "Negative indexing allows access from the end, e.g., `arr[-1]` for the last element.",
            "``````\narr = [10, 20, 30, 40, 50]\nprint(arr[0])  # Output: 10\nprint(arr[-1]) # Output: 50\n```",
            "Indexing is crucial for accessing and manipulating elements in arrays."
          ]
        },
        {
          "page_no": 5,
          "heading": "Common Array Operations",
          "content": [
            "Arrays support various operations: insertion, deletion, searching, and traversal.",
            "Insertion can be at the end (append), at a specific index, or at the beginning.",
            "Deletion can remove an element by value or by index.",
            "Searching can be done using linear search or binary search (for sorted arrays).",
            "Traversal involves visiting each element in the array.",
            "``````\n#Example of inserting an element at the end:\narr.append(60)\nprint(arr)  # Output: [1, 2, 3, 4, 5, 60]\n \n#Example of deleting an element by value:\narr.remove(3)\n \n#Example of poping an element. \narr.pop() #output: [1, 2, 4, 5]\nprint(arr)  # Output: [1, 2, 4, 5, 60]\n \nExample of traversing an array:\nfor element in arr:\n    print(element)\n```"
          ]
        }
      ]
    },
    {
      "lesson_no": 2,
      "title": "Arrays : Advanced Concepts and Questions.",
      "time": "50 minutes",
      "description": "Dive into arrays(advance concepts).",
      "pages": [
        {
          "page_no": 1,
          "heading": "Arrays - Types of problems.",
          "content": [
            "There are many types of array problem pattens that they can be divided into.",
            "- two pointers",
            "- sliding window",
            "Lets one by one go over problems related to these patterns. But first lets see some simple questions related to arrays.",
            "How would you find the maximum and minimum elements in an array?",
            "Hint - You can iterate through the array and keep track of the maximum and minimum values found so far.",
            "Think about how you would implement this in Python.",
            "https://i.pinimg.com/736x/db/7b/c3/db7bc3f79fee605257b6e79ea5468771.jpg"
          ]
        },
        {
          "page_no": 2,
          "heading": "Finding Maximum and Minimum",
          "content": [
            "To find the maximum and minimum elements in an array, you can use a simple loop. Just initialize two variables to hold the maximum and minimum values, then iterate through the array to update these variables. Here's a Python example:",
            "```\narr=[10, 2, 21, 4, 5] \n\nmax_value = arr[0]\nmin_value = arr[0]\n\nfor num in arr:\n    if num > max_value:\n        max_value = num\n    if num < min_value:\n        min_value = num\n\nprint('Maximum:', max_value)\nprint('Minimum:', min_value)\n```",
            "You can copy and paste this code into our online compiler to see it in action and viualize it step by step by clicking on the 'visualize' button.",
            "https://i.pinimg.com/736x/8a/18/25/8a18253f80e1e2c12d3c2b1816bc52e5.jpg",
            "This code iterates through the array, comparing each element to the current maximum and minimum values, updating them as necessary."
          ]
        },
        {
          "page_no": 3,
          "heading": "Finding the Sum and Average",
          "content": [
            "To find the sum and average of elements in an array, you can use a loop to accumulate the sum and then divide by the number of elements for the average. Here's how you can do it in Python:",
            "```\narr = [10, 20, 30, 40, 50]\n\nsum_value = sum(arr)\naverage_value = sum_value / len(arr)\n\nprint('Sum:', sum_value)\nprint('Average:', average_value)\n```",
            "You can copy and paste this code into our online compiler to see it in action and visualize it step by step by clicking on the 'visualize' button.",
            "This does the same thing as the previous code but instead of just reasing the value we are adding to it.",
            "https://i.pinimg.com/1200x/33/14/5a/33145aed18638d42efc6361017846b19.jpg"
          ]
        }
      ]
    },
    {
      "lesson_no": 3,
      "title": "Solve this amazing problem on how to find the closest number to zero in an array. Don't worry, we will solve it together in the next lesson Just give it a try.",
      "time": "25 minutes",
      "external_link": "/cp_compiler/1"
    },
    {
      "lesson_no": 4,
      "title": "Solving the previous problem together.",
      "time": "15 minutes",
      "description": "Test your knowledge with this quiz on arrays.",
      "pages" : [
        {
          "page_no": 1,
          "heading": "Finding the Closest Number to Zero",
          "content": [
            "So was that tuff? Don't worry, we will solve it together in this lesson.",
            "To find the closest number to zero in an array, you can iterate through the array and keep track of the number that is closest to zero. Here's a Python example:",
            "```\narr = [3, -2, 5, -1, 4]\n\nclosest_to_zero = arr[0]\n\nfor num in arr:\n    if abs(num) < abs(closest_to_zero) or (abs(num) == abs(closest_to_zero) and num > closest_to_zero):\n        closest_to_zero = num\n\nprint('Closest to zero:', closest_to_zero)\n```",
            "You can copy and paste this code into our online compiler to see it in action and visualize it step by step by clicking on the 'visualize' button.",
            "This code checks each number's absolute value against the current closest number's absolute value, updating it when a closer number is found."
          ]
        },
        {
          "page_no": 2,
          "heading": "Understanding the Logic",
          "content": [
            "The logic behind this solution is to compare the absolute values of the numbers in the array. If a number's absolute value is less than the current closest number's absolute value, it becomes the new closest number. If they are equal, we choose the positive one.",
            "```if abs(num) < abs(closest_to_zero) or (abs(num) == abs(closest_to_zero) and num > closest_to_zero):\n        closest_to_zero = num\n\n```",
            "This ensures that we always find the closest number to zero, even if there are both positive and negative numbers in the array."
          ]
        }
      ]
    },
    {
      "lesson_no": 5,
      "title": "Arrays Basics Quiz",
      "time": "10 minutes",
      "external_link": "/quiz",
      "description": "Test your knowledge with this quiz on Arrays concepts."
    },
    {
      "lesson_no": 6,
      "title": "Here's another fun problem related to arrays that you can try to solve.",
      "time": "25 minutes",
      "external_link": "/cp_compiler/2"
    },
    {
      "lesson_no": 7,
      "title": "Recursion & Backtracking",
      "time": "50 minutes",
      "description": "Explore recursive thinking, stack frames, and the fundamentals of backtracking algorithms.",
      "pages": [
        {
          "page_no": 1,
          "heading": "Understanding Recursion",
          "content": [
            "A recursive function calls itself to solve smaller instances of a problem.",
            "Every recursion has a base case and a recursive case.",
            "https://i.pinimg.com/736x/d1/f8/f2/d1f8f291b4f316e8ae9aa1e59796b9b9.jpg",
            "Recursive solutions often closely follow the problem's structure."
          ]
        },
        {
          "page_no": 2,
          "heading": "Backtracking: Overview",
          "content": [
            "Backtracking is a method of trying out different solutions and reverting (backtracking) when a path fails.",
            "Used in puzzles, mazes, and combinatorial problems.",
            "https://i.pinimg.com/736x/f8/4a/42/f84a42ffbcedff6dfdffc585a3d09e73.jpg",
            "Returns to previous decisions when a path doesn't lead to a solution."
          ]
        },
        {
          "page_no": 3,
          "heading": "Recursion Example: Factorial",
          "content": [
            "Let's compute the factorial of a number recursively.",
            "```def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n```",
            "This function multiplies n by the factorial of n-1.",
            "https://i.pinimg.com/736x/8d/6b/0f/8d6b0fb37227611752713e3e60e3d5c1.jpg"
          ]
        }
      ]
    },
    {
      "lesson_no": 8,
      "title": "Trees and Binary Trees",
      "time": "55 minutes",
      "description": "Understand hierarchical data structures, how trees are constructed, and traverse binary trees in different ways.",
      "pages": [
        {
          "page_no": 1,
          "heading": "Introduction to Trees",
          "content": [
            "A tree is a hierarchical structure with nodes connected by edges.",
            "A binary tree is a tree in which each node has at most two children.",
            "https://i.pinimg.com/1200x/c6/b0/fd/c6b0fd57723b8eea88c0184c64c7553c.jpg",
            "Key terms: root, leaf, height, depth, subtree."
          ]
        },
        {
          "page_no": 2,
          "heading": "Tree Traversals",
          "content": [
            "Trees can be traversed in various orders: preorder, inorder, postorder (all depth first), level order (breadth first).",
            "Inorder traversal on BST yields a sorted sequence.",
            "https://i.pinimg.com/1200x/1c/b9/c8/1cb9c8bd2ab3444a050f7178af58594e.jpg",
            "Traversal methods can be implemented recursively or iteratively."
          ]
        },
        {
          "page_no": 3,
          "heading": "Binary Tree Example: Inorder Traversal",
          "content": [
            "Let's perform an inorder traversal of a binary tree.",
            "```class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef inorder(root):\n    if root:\n        inorder(root.left)\n        print(root.data)\n        inorder(root.right)\n```",
            "Inorder traversal visits left, root, and right nodes.",
            "https://i.pinimg.com/1200x/7f/87/e9/7f87e91ec7b53e6dcb8ffc9670bcd906.jpg"
          ]
        }
      ]
    },
    {
      "lesson_no": 9,
      "title": "Binary Search Trees & Balanced Trees",
      "time": "60 minutes",
      "description": "Learn about Binary Search Trees (BST), AVL Trees, and why balancing matters for fast search and update operations.",
      "pages": [
        {
          "page_no": 1,
          "heading": "Binary Search Trees",
          "content": [
            "A BST is a binary tree where left child < parent < right child.",
            "BSTs allow fast lookup, insert, and delete (O(log n) average).",
            "https://i.pinimg.com/1200x/cb/fa/a0/cbfaa06f2ddd34aed0e7aa54b25dcb8e.jpg",
            "Can degrade to a linked list if not balanced."
          ]
        },
        {
          "page_no": 2,
          "heading": "AVL and Red-Black Trees",
          "content": [
            "AVL and Red-Black Trees are self-balancing BSTs.",
            "Balancing keeps operations efficient even in worst cases.",
            "https://i.pinimg.com/736x/54/c0/6e/54c06e53e8fc6fcd1f075b97afffd04a.jpg",
            "Balance is maintained through rotations after inserts or deletes."
          ]
        },
        {
          "page_no": 3,
          "heading": "BST Example: Insert Operation",
          "content": [
            "Let's insert a node recursively into a BST.",
            "```class Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef insert(root, key):\n    if root is None:\n        return Node(key)\n    if key < root.val:\n        root.left = insert(root.left, key)\n    else:\n        root.right = insert(root.right, key)\n    return root\n```",
            "Each insert preserves the BST property.",
            "https://i.pinimg.com/736x/33/91/c9/3391c9d2588625fa3f17af33a98c58c3.jpg"
          ]
        }
      ]
    },
    {
      "lesson_no": 10,
      "title": "Hash Tables and Sets",
      "time": "40 minutes",
      "description": "Understand the power of hashing for fast data lookups, implementation challenges, and the idea of sets.",
      "pages": [
        {
          "page_no": 1,
          "heading": "Hash Tables: Mapping Keys to Values",
          "content": [
            "A hash table uses a hash function to map keys to indices for fast access.",
            "Supports nearly constant-time insert, find, and delete.",
            "https://i.pinimg.com/1200x/fd/73/0b/fd730b3d552b64a1261356f94de5b391.jpg",
            "Collisions are handled by chaining or open addressing."
          ]
        },
        {
          "page_no": 2,
          "heading": "Sets and Uniqueness",
          "content": [
            "Sets store unique elements, often using a hash table for fast checks.",
            "Operations: add, remove, membership, union, intersection.",
            "https://i.pinimg.com/736x/40/e6/70/40e670d1ac9e1490c7864f8d2d8046f3.jpg",
            "Useful for removing duplicates and set algebra."
          ]
        },
        {
          "page_no": 3,
          "heading": "Hash Table Example: Word Count",
          "content": [
            "Let's count word frequencies in a text using a hash table.",
            "```def count_words(text):\n    counts = {}\n    for word in text.split():\n        word = word.lower()\n        counts[word] = counts.get(word, 0) + 1\n    return counts\n```",
            "A classic real-world application for hashing.",
            "https://i.pinimg.com/736x/bb/df/c3/bbdfc33ce3dd684161256143da9f3278.jpg"
          ]
        }
      ]
    },
    {
      "lesson_no": 11,
      "title": "Sorting & Searching Algorithms",
      "time": "45 minutes",
      "description": "Master some of the most important basic algorithms: searching and sorting for arrays/lists.",
      "pages": [
        {
          "page_no": 1,
          "heading": "Searching Algorithms: Linear and Binary Search",
          "content": [
            "Linear search scans each element sequentially. Binary search splits sorted arrays in log(n) steps.",
            "Binary search is only valid on sorted arrays.",
            "https://i.pinimg.com/736x/b5/8f/2b/b58f2bd68913cc9933df2259f1ead950.jpg",
            "Efficient search is essential in large datasets."
          ]
        },
        {
          "page_no": 2,
          "heading": "Sorting Algorithms: Selection, Merge, Quick Sort",
          "content": [
            "Sorting arranges elements in ascending or descending order.",
            "Merge sort and quicksort are efficient recursive sorts (O(n log n)).",
            "https://i.pinimg.com/736x/74/52/f5/7452f5448ddf386c4ab6660bf10dfcbb.jpg",
            "Sorting is often a prerequisite for efficient searching."
          ]
        },
        {
          "page_no": 3,
          "heading": "Sorting Example: Quick Sort",
          "content": [
            "Here's a simple implementation of the quicksort algorithm.",
            "```def quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n```",
            "Quick sort is widely used in practice for large datasets.",
            "https://i.pinimg.com/736x/73/4a/86/734a867a25413b03c222d4855aa7de3e.jpg"
          ]
        }
      ]
    }
  ]
}
